package Arrays;

/*

Description:
    Following program demonstrates the solution to the "Find Pivot Index" problem
    using prefix sum and total sum comparison...

Problem Statement:
    -> Given an array of integers nums...
    -> The pivot index is the index where the sum of all elements to the left equals the sum of all elements to the right...
    -> If no such index exists, return -1...
    -> If there are multiple pivot indices, return the leftmost pivot index...

Approach:
    > Prefix Sum Comparison:
        i. Calculate the total sum of all elements in the array...
        ii. Iterate through the array and compare left sum with right sum at each position...
        iii. Return the first index where left sum equals right sum...

    > Algorithm Steps:
        -> Initialization:
            1. Calculate the total sum of all elements in the array...
            2. Initialize a temporary variable to track the running sum from left...

        -> Pivot search:
            1. Iterate through each index of the array...
            2. At each index i, check if the sum to the left (temp) equals the sum to the right...
            3. The sum to the right can be calculated as (total sum - left sum - current element)...
            4. If equality is found, return the current index as the pivot index...
            5. Otherwise, update the left sum by adding the current element...

        -> Result handling:
            1. If no pivot index is found after the iteration, return -1...

    > Key Characteristics:
        -> Requires only two passes through the array (one for total sum, one for finding pivot)...
        -> Works with arrays containing both positive and negative integers...
        -> Handles edge cases where the pivot is at the beginning or end of the array...
        -> Returns the leftmost pivot index if multiple exist...
        -> Returns -1 when no valid pivot index exists...

    > Implementation Details:
        -> Uses constant extra space regardless of input size...
        -> Avoids recalculating sums by using a running total approach...
        -> Demonstrates the solution with an example array containing [1, 7, 3, 6, 5, 6]...
        -> Efficiently compares left and right sums without actually creating separate arrays...
        -> For an index to be a pivot, the equation temp == sum - temp - nums[i] must be satisfied...

    > Time and Space Complexity:
        -> Time Complexity: O(n) where n is the length of the array...
        -> Space Complexity: O(1) as only constant extra space is used...
        -> Single traversal approach after initial sum calculation...
   
*/

public class Find_Pivot_Index {

    private static int pivotIndex(int[] nums) {

        int sum = 0;
        int temp = 0;

        for (int num : nums) {
            sum += num;
        }

        for (int i = 0; i < nums.length; i++) {
            if (temp == sum - temp - nums[i]) {
                return i;
            }
            temp += nums[i];
        }
        return - 1;

    }

    public static void main(String[] args) {

        int[] nums = {1, 7, 3, 6, 5, 6};
        System.out.println("The pivot index is = " + pivotIndex(nums));

    }

}
