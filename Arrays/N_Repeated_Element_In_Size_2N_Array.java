package Arrays;

/*

Description:
  This program finds the element that is repeated N times in an array of size 2N...
  Exactly one element appears N times, while all other elements appear only once...

Problem Statement:
  -> You are given an integer array of size 2N...
  -> One element is repeated exactly N times...
  -> All other elements are distinct...
  -> You must identify and return the repeated element...

Key Observation:
  -> Since one element appears N times, it must appear very close to itself...
  -> In a random or partially ordered array, repeated values will occur:
       • Either adjacent (i and i+1)...
       • Or with one gap (i and i+2)...
  -> This allows detection without sorting or extra memory...

Approach:
  > Two-pass neighbor comparison strategy:
     i. First pass:
           -> Compare each element with its immediate next element...
           -> If numbers[i] == numbers[i+1], return it immediately...
     ii. Second pass:
           -> Compare each element with the element two positions ahead...
           -> If numbers[i] == numbers[i+2], return it...
     iii. Fallback:
           -> If neither comparison catches it, the first element must be the repeated one...

Algorithm Steps:
  -> Step 1: Loop from index 0 to length-2...
       * If numbers[i] == numbers[i+1], return numbers[i]...
  -> Step 2: Loop from index 0 to length-3...
       * If numbers[i] == numbers[i+2], return numbers[i]...
  -> Step 3: Return numbers[0] as guaranteed repeated element...

Why This Works:
  -> With N repetitions in 2N positions, the repeated element cannot be spaced far apart...
  -> Pigeonhole principle ensures at least one close repetition...
  -> Avoids hashing, sorting, or frequency arrays...
  -> Extremely fast and memory-efficient...

Examples:
  -> [1, 2, 3, 3] → repeated = 3...
  -> [2, 1, 2, 5, 3, 2] → repeated = 2...
  -> [7, 7, 8, 9] → repeated = 7...

Edge Cases:
  -> Repeated elements at the start of array...
  -> Repeated elements at the end of array...
  -> Minimal array size (2 elements)...
  -> No need to handle invalid input (problem guarantees one solution)...

Time and Space Complexity:
  -> Time Complexity: O(n)...
  -> Space Complexity: O(1)...

Summary:
  -> Smart observation-based solution...
  -> No extra memory used...
  -> Faster than sorting or hash-based approaches...
  -> Ideal for interview and competitive programming problems...

*/

import java.util.Arrays;

public class N_Repeated_Element_In_Size_2N_Array {

    private static int repeatedNTimes(int[] numbers) {

        for (int i = 0; i < numbers.length - 1; i++) {
            if (numbers[i] == numbers[i + 1]) {
                return numbers[i];
            }
        }

        for (int i = 0; i < numbers.length - 2; i++) {
            if (numbers[i] == numbers[i + 2]) {
                return numbers[i];
            }
        }

        return numbers[0];
    }

    public static void main(String[] args) {
        
        int[][] testCases = {
            {1, 2, 3, 3},
            {2, 1, 2, 5, 3, 2},
            {5, 1, 5, 2, 5, 3, 5, 4},
            {9, 5, 6, 9},
            {7, 7, 8, 9}
        };

        System.out.println("=".repeat(50));
        System.out.println("N-REPEATED ELEMENT IN SIZE 2N ARRAY");
        System.out.println("=".repeat(50));

        for (int i = 0; i < testCases.length; i++) {

            int result = repeatedNTimes(testCases[i]);

            System.out.printf("Test %d: Array = %s\n", (i + 1), Arrays.toString(testCases[i]));
            System.out.printf("         Repeated Element = %d\n\n", result);
        }

        System.out.println("=".repeat(50));

    }

}
