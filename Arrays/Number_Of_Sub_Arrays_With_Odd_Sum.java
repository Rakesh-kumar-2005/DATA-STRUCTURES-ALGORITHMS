package Arrays;

/*

Description:
    -> Following program demonstrates the solution to the "Number of Sub-Arrays with Odd Sum" problem...
    -> It efficiently counts sub-arrays whose elements sum to an odd value...
    -> Uses prefix sum technique combined with parity tracking...

Problem Statement:
    -> Given an array of integers arr...
    -> The task is to count the number of contiguous sub-arrays with odd sum...
    -> A sub-array is a contiguous subsequence of the array...
    -> Return the count modulo 10^9 + 7...

Approach:
    > Prefix Sum with Parity Tracking:
        i. Track the running sum and maintain counts of even and odd prefix sums...
        ii. Use mathematical properties of odd and even numbers to count valid sub-arrays...
        iii. Any sub-array with odd sum can be identified using parity of prefix sums...

    > Algorithm Steps:
        -> Initialize counters:
            1. Set odd counter to 0 (no odd prefix sums initially)...
            2. Set even counter to 1 (empty prefix has sum 0, which is even)...
            3. Set result and running sum to 0...

        -> Process each element:
            1. Add current element to running sum...
            2. Check parity of the current running sum...
            3. If sum is even:
                a. Add 'odd' count to result (sub-arrays ending at current position with odd sum)...
                b. Increment 'even' counter...
            4. If sum is odd:
                a. Add 'even' count to result (sub-arrays ending at current position with odd sum)...
                b. Increment 'odd' counter...
            5. Take modulo 10^9 + 7 to prevent overflow...

    > Key Characteristics:
        -> Uses mathematical property: (odd - even = odd) and (odd - odd = even)...
        -> Efficiently counts sub-arrays without generating them explicitly...
        -> Handles large arrays with single pass...
        -> Maintains modulo operation to prevent integer overflow...
        -> Works with both positive and negative integers...

    > Implementation Details:
        -> Uses constant modulo value (10^9 + 7) for large results...
        -> Initializes even counter to 1 (accounting for empty prefix)...
        -> Processes each array element exactly once...
        -> Uses running sum approach instead of storing all prefix sums...
        -> Returns final result after modulo operation...

    > Time and Space Complexity:
        -> Time Complexity: O(n) where n is the length of the array...
        -> Single pass through the array with constant-time operations...
        -> Space Complexity: O(1) using only a constant amount of extra space...
        -> No auxiliary data structures are required except for a few variables...

*/

public class Number_Of_Sub_Arrays_With_Odd_Sum {

    private static int numOfSubArrays(int[] arr) {

        int mod = 1000000007;
        int odd = 0;
        int even = 1;

        int result = 0;
        int sum = 0;

        for (int num : arr) {

            sum += num;

            if (sum % 2 == 0) {
                result = (result + odd) % mod;
                even++;
            } else {
                result = (result + even) % mod;
                odd++;
            }
        }
        return result;
    }

    public static void main(String[] args) {

        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        System.out.println("The number of sub-arrays with odd sum is = " + numOfSubArrays(arr));

    }

}
