package Arrays;

/*

Description:
    -> Following program demonstrates the solution to the "Tuple With Same Product" problem...
    -> It counts the number of tuples (a,b,c,d) where a*b = c*d...
    -> The solution uses a hash map to efficiently track products of pairs...

Problem Statement:
    -> Given an array of distinct integers nums...
    -> Find the number of tuples (a,b,c,d) where:
        i. a, b, c, and d are distinct elements...
        ii. a, b, c, and d are elements of nums...
        iii. a * b = c * d...
    -> Return the count of such tuples...

Approach:
    > Product Frequency Counting:
        i. Calculate products of all possible pairs of numbers...
        ii. Count the frequency of each product using a TreeMap...
        iii. Use the frequency to calculate the number of valid tuples...

    > Algorithm Steps:
        -> Handle edge case:
            1. Return 0 if array has fewer than 4 elements...
            2. Otherwise, proceed with the main algorithm...

        -> Count product frequencies:
            1. Create a TreeMap to store the product frequencies...
            2. Use nested loops to generate all unique pairs (i,j) where i < j...
            3. Calculate product of each pair: nums[i] * nums[j]...
            4. For each product, update its frequency in the map...

        -> Calculate tuple count:
            1. For each pair and its product, add to the tuple count...
            2. If product appears multiple times, it means multiple tuples can be formed...
            3. For each new pair, add 8 * frequency of existing pairs with the same product...
            4. The factor 8 accounts for all possible arrangements of (a,b,c,d)...

    > Key Characteristics:
        -> Works with array of distinct integers...
        -> Handles all possible permutations of tuples...
        -> Uses TreeMap for organized storage and retrieval...
        -> Efficiently counts tuples without generating them explicitly...
        -> Accounts for ordering variations through the multiplier 8...

    > Implementation Details:
        -> Uses TreeMap to track product frequencies...
        -> Processes each pair exactly once with nested loops...
        -> Multiplies by 8 to account for all permutations:
            - (a,b,c,d), (a,b,d,c), (b,a,c,d), (b,a,d,c)...
            - (c,d,a,b), (c,d,b,a), (d,c,a,b), (d,c,b,a)...
        -> Updates frequency count incrementally...
        -> Returns the total count of valid tuples...

    > Time and Space Complexity:
        -> Time Complexity: O(n²) where n is the length of the array...
        -> The nested loops process all pairs of elements...
        -> Space Complexity: O(n²) in worst case for storing products...
        -> TreeMap stores at most n*(n-1)/2 different products...
   
*/

import java.util.TreeMap;

public class Tuple_With_Same_Product {

    private static int tupleSameProduct(int[] nums) {

        if (nums.length < 4) {
            return 0;
        }

        int n = nums.length;
        int count = 0;

        TreeMap<Integer, Integer> map = new TreeMap<>();

        for (int i = 0; i < n - 1; i++) {

            for (int j = i + 1; j < n; j++) {

                int currVal = nums[i] * nums[j];
                count += 8 * map.getOrDefault(currVal, 0);

                map.put(currVal, map.getOrDefault(currVal, 0) + 1);
            }

        }
        return count;

    }

    public static void main(String[] args) {

        int[] nums = {1, 2, 4, 5, 10};
        System.out.println("The number of tuples with same product is = " + tupleSameProduct(nums));
        
    }

}
