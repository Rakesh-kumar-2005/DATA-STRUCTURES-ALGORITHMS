package Arrays;

/*

Description:
    Following program demonstrates the solution to the "Maximum Ascending Subarray Sum" problem
    using single-pass scanning with sum tracking...

Problem Statement:
    -> Given an array of positive integers nums...
    -> Find the maximum sum of an ascending subarray...
    -> An ascending subarray is a contiguous sequence where each element is strictly greater than the previous element...
    -> Return the maximum sum among all possible ascending subarrays...

Approach:
    > Single Pass with Sum Tracking:
        i. Traverse the array once while maintaining the current ascending subarray sum...
        ii. Track the maximum sum encountered during the traversal...
        iii. Reset the current sum when the ascending property is violated...

    > Algorithm Steps:
        -> Initialization:
            1. Initialize maxSum to Integer.MIN_VALUE to handle edge cases...
            2. Initialize tempSum to 0 to track the current ascending subarray sum...
            3. Initialize index i to 0 for array traversal...

        -> Main traversal loop:
            1. Add the current element to the temporary sum (tempSum += nums[i])...
            2. Update the maximum sum if current sum is greater (maxSum = Math.max(maxSum, tempSum))...
            3. Check if the ascending property is violated for the next element...
            4. If nums[i] >= nums[i+1], reset tempSum to 0 for the next subarray...
            5. Increment the index to move to the next element...

        -> Result calculation:
            1. Return the maximum sum found during the traversal...

    > Key Characteristics:
        -> Works with arrays containing only positive integers...
        -> Handles single-element subarrays correctly (each element forms a valid ascending subarray)...
        -> Efficiently processes the array in a single pass without backtracking...
        -> Correctly identifies when to start a new ascending subarray...
        -> Uses greedy approach to maintain running sums and maximum tracking...

    > Implementation Details:
        -> Uses Integer.MIN_VALUE to handle potential edge cases with negative results...
        -> The condition (i != n-1 && nums[i] >= nums[i+1]) ensures we don't access out-of-bounds elements...
        -> tempSum is reset to 0 when the ascending property breaks, starting fresh for next subarray...
        -> Math.max() function efficiently compares and updates the maximum sum...
        -> The algorithm correctly handles both strictly increasing and non-increasing sequences...

    > Time and Space Complexity:
        -> Time Complexity: O(n) where n is the length of the array...
        -> Space Complexity: O(1) as only constant extra space is used...
        -> Single traversal approach without requiring additional data structures...
   
*/

public class Maximum_Ascending_Subarray_Sum {

    private static int maxAscendingSum(int[] nums) {

        int n = nums.length;
        int maxSum = Integer.MIN_VALUE;
        
        int i = 0;
        int tempSum = 0;

        while (i < n) {
            tempSum += nums[i];
            maxSum = Math.max(maxSum, tempSum);

            if (i != n - 1 && nums[i] >= nums[i + 1]) {
                tempSum = 0;
            }
            i++;
        }

        return maxSum;

    }

    public static void main(String[] args) {

        int[] nums = {10, 20, 30, 5, 10, 50};
        System.out.println("The maximum ascending subarray sum is : " + maxAscendingSum(nums));

    }

}
