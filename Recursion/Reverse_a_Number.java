package Recursion;

/*

    Description:
        Following program demonstrates the implementation of "Integer Reversal"
        using a recursive approach...

    Problem Statement:
        -> Given a positive integer...
        -> The task is to reverse the digits of the number (e.g., 123 becomes 321)...
        -> The reversal must be performed through mathematical operations rather than string conversion...
        -> This demonstrates numeric manipulation through recursion...

    Approach:
        > Recursive Digit Reversal:
            i. Use recursion to build the reversed number digit by digit...
            ii. Maintain a running sum that accumulates the reversed result...
            iii. Follow a specific reversal strategy:
                a. Extract the last digit of the current number using modulo operation (n % 10)...
                b. Add this digit to the running sum after shifting existing digits left (sum * 10)...
                c. Recursively process the remaining digits (n / 10)...
            iv. The recursion terminates when no digits remain (n becomes 0)...

    Algorithm Steps:
        -> Recursive Number Reversal Implementation:
            1. Check base case: If n equals 0, return the accumulated sum...
            2. Extract the last digit of n using n % 10...
            3. Update the sum: sum = sum * 10 + (last digit)...
            4. Recursively call reverseNumber with n/10 (removing the last digit) and the updated sum...
        -> Main Method Flow:
            1. Call reverseNumber function with the test number 5647382 and initial sum 0...
            2. Print the resulting reversed number...

    Key Characteristics:
        -> Processes the number from right to left (least significant to most significant digit)...
        -> Uses tail recursion where the recursive call is the final operation...
        -> Builds the reversed number progressively with each recursive call...
        -> Operates directly on numeric values without string conversion...

        > Implementation Details:
            -> Function accepts two integer parameters: the number to reverse and the accumulated sum...
            -> Returns the reversed integer rather than printing it...
            -> Uses modulo and division operations for digit extraction and manipulation...
            -> Tests with the number 5647382...

    Time and Space Complexity:
        -> Time Complexity: O(log n) where n is the input number (proportional to number of digits)...
        -> Space Complexity: O(log n) for the recursion stack...

    Output Analysis:
        -> For input 5647382, the output will be 2837465...
        -> Each digit's position is exactly reversed from its original position...

    Note:
        -> The algorithm handles positive integers correctly...
        -> For negative numbers, additional handling would be needed...
        -> There's a potential for integer overflow if the reversed number exceeds the range of int...

*/

public class Reverse_a_Number {

    public static int reverseNumber(int n,int sum){
        if (n == 0)return sum;
        sum = sum * 10 + n % 10;
        return reverseNumber(n/10,sum);
    }
    
    public static void main(String[] args) {
        int num = 5647382;
        System.out.println("Original number is : " + num);
        System.out.println("After Reversing the number : " + reverseNumber(num,0));
    }
    
}
