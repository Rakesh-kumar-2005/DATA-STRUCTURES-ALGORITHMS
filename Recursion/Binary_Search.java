package Recursion;

/*

    Description:
        Following program demonstrates the implementation of the "Binary Search" algorithm
        using a recursive approach...

    Problem Statement:
        -> Given a sorted array of integers...
        -> The task is to find whether a specific element exists in the array...
        -> Binary search efficiently finds elements by repeatedly dividing the search interval in half...
        -> This approach has logarithmic time complexity, making it much faster than linear search for large arrays...

    Approach:
        > Recursive Binary Search:
            i. Use the divide-and-conquer strategy to efficiently find the target element...
            ii. Exploit the sorted nature of the array to eliminate half of the remaining elements each time...
            iii. Follow a specific search strategy:
                a. Find the middle element of the current search range...
                b. Compare target with middle element...
                c. If found, return the position...
                d. If target is smaller, search in the left half...
                e. If target is larger, search in the right half...
            iv. Recursively apply this strategy to smaller and smaller portions of the array...

    Algorithm Steps:
        -> Recursive Binary Search Implementation:
            1. Calculate the middle index of the current search range (start to end)...
            2. Check base case: If start > mid, element doesn't exist in array...
            3. If the middle element equals the target, return its index...
            4. If the middle element is greater than the target:
               - Recursively search in the left half (start to mid-1)...
            5. If the middle element is less than the target:
               - Recursively search in the right half (mid to end)...
        -> Main Method Flow:
            1. Define a sorted test array...
            2. Call the binary search function with initial range (0 to array length-1) and target element...
            3. Print the result (element found or not found)...

    Key Characteristics:
        -> Efficiently searches sorted arrays in O(log N) time...
        -> Divides the search space in half with each comparison...
        -> Returns the index if element is found, or indication that element doesn't exist...
        -> Uses recursion to implement the divide-and-conquer approach...

        > Implementation Details:
            -> Handles arrays of integers...
            -> Uses inclusive bounds for the search range...
            -> Prints the result rather than returning it...
            -> Includes error handling for elements not found in the array...

    Time and Space Complexity:
        -> Time Complexity: O(log N) where N is the number of elements in the array...
        -> Space Complexity: O(log N) for the recursion stack...

    Bug/Issue:
        -> There's a potential issue in the recursive case when arr[mid] < ele:
           The algorithm uses (mid, end) as the new range instead of (mid+1, end)...
           This can lead to infinite recursion in some cases since mid might never change...
           A correct implementation should use (mid+1, end) to ensure the search range decreases...

*/

public class Binary_Search {
    
    public static void binarySearch(int[] arr,int start, int end, int ele){
        
        int mid = (start+end)/2;
        
        if (start > mid){
            System.out.println("Element isn't in the array...");
            return;
        } 
        else if (arr[mid] == ele) {
            System.out.println("Desired element found at index " + mid);
            return;
        }
        else if (arr[mid] > ele){
            binarySearch(arr, start, mid-1, ele);
        }
        else
            binarySearch(arr, mid, end, ele);
    }
    public static void main(String[] args) {
        int[] arr = {1,2,3,4,5,6,7,8,9};
        binarySearch(arr,0,8,7);
    }
}
