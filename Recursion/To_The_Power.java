package Recursion;

/*

Description:
    This program calculates the power of a number using recursion...
    It computes m^n (m raised to the power of n) where m is the base and n is the exponent...

Problem Statement:
    -> Given two integers m and n, calculate m raised to the power of n (m^n)...
    -> For example, 5^4 = 5 * 5 * 5 * 5 = 625...
    -> The program implements a recursive approach to solve this problem...

Approach:
    > Recursive Power Calculation:
        1. Use the property that m^n = m * m^(n-1)...
        2. Break down the calculation into smaller subproblems...
        3. Handle special cases appropriately (n=0, m=0, n=1)...

Algorithm Steps:
    -> calcPow() Method:
        1. Base cases:
           - If n=0, return 1 (any number raised to power 0 is 1)...
           - If m=0, return 0 (0 raised to any power except 0 is 0)...
           - If n=1, return m (any number raised to power 1 is itself)...
        2. Recursive case:
           - Return m multiplied by m^(n-1)...
           - m^(n-1) is calculated by recursive call to calcPow(m, n-1)...
        
    -> Main Method Flow:
        1. Call calcPow() with arguments 5 and 4...
        2. Print the result of 5^4...

Key Characteristics:
    -> Uses linear recursion (each call makes only one recursive call)...
    -> Implements a top-down approach to break down the problem...
    -> Handles edge cases for exponents 0 and 1, and base 0...
    -> Each recursive call reduces the exponent by 1 until reaching a base case...
    -> Follows the mathematical definition: m^n = m * m^(n-1)...

Implementation Details:
    -> The package is named "Recursion"...
    -> Uses a public static method for the recursive algorithm...
    -> Takes two integer parameters: m (base) and n (exponent)...
    -> Returns an integer result...
    -> Tests the implementation with a specific example: 5^4...

Time and Space Complexity:
    -> Time Complexity: O(n) where n is the exponent...
       (Each recursive call decrements n by 1, resulting in n recursive calls)...
    -> Space Complexity: O(n) for the recursion stack...
       (Maximum depth equals the exponent value)...

Potential Improvement:
    -> Could implement a more efficient algorithm using binary exponentiation (O(log n))...
    -> Could add input validation to handle negative exponents...
    -> Could handle potential integer overflow for large results...
    -> Could be modified to work with floating-point numbers...

*/

public class To_The_Power {

    public static int calcPow(int m ,int n){
        if(n == 0) {
            return 1;
        }
        if (m == 0) {
            return 0;
        }
        if (n == 1) {
            return m;
        }
        return m * calcPow(m,n-1);
    }
    public static void main(String[] args) {
        
        System.out.println("Some examples would be like : ");
        System.out.println("5 to the power 4 would be = " + calcPow(5,4));
    }
}
