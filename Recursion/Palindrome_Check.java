package Recursion;

/*

    Description:
        Following program demonstrates the implementation of a "Palindrome Check" algorithm
        using a recursive approach...

    Problem Statement:
        -> Given a string...
        -> The task is to determine whether it is a palindrome...
        -> A palindrome reads the same forward and backward (e.g., "madam", "racecar", "radar")...
        -> The check must compare characters from both ends, moving inward until the middle is reached...

    Approach:
        > Recursive Palindrome Verification:
            i. Use recursion to compare characters from both ends of the string...
            ii. Move inward with each recursive call until the pointers meet or cross...
            iii. Follow a specific verification strategy:
                a. Compare characters at positions i (start) and j (end)...
                b. If they match, recursively check the substring from i+1 to j-1...
                c. If any characters don't match, immediately return false...
                d. If pointers meet or cross (checked all characters), return true...
            iv. The recursion terminates when all characters are checked or a mismatch is found...

    Algorithm Steps:
        -> Recursive Palindrome Implementation:
            1. Check base case: If i >= j (pointers have met or crossed), return true...
            2. Compare characters at positions i and j:
               - If they don't match, return false (not a palindrome)...
               - If they match, increment i, decrement j...
            3. Recursively call isPalindrome with updated indices...
        -> Main Method Flow:
            1. Define a test string "madam"...
            2. Call isPalindrome function with the string and initial indices (0 and 4)...
            3. Print whether the string is a palindrome or not...

    Key Characteristics:
        -> Efficiently checks if a string is a palindrome without using extra space...
        -> Uses two-pointer technique from both ends of the string...
        -> Short-circuits as soon as any mismatch is found...
        -> Demonstrates divide-and-conquer with recursion...

        > Implementation Details:
            -> Function accepts three parameters: the string and two indices...
            -> Returns a boolean result rather than printing it...
            -> Uses charAt() method to access individual characters...
            -> Hardcodes the end index in the main method call...

    Time and Space Complexity:
        -> Time Complexity: O(n/2) ≈ O(n) where n is the length of the string...
        -> Space Complexity: O(n/2) ≈ O(n) for the recursion stack...

    Potential Improvements:
        -> The end index is hardcoded as 4 in the main method, which makes the function less reusable...
        -> Could be improved by using s.length()-1 instead of hardcoding the end index...
        -> Could add preprocessing to handle case insensitivity and non-alphanumeric characters...

*/

public class Palindrome_Check {
    
    public static boolean isPalindrome(String s, int i, int j){
        if (i >= j){
            return true;
        }
        
        if (s.charAt(i) != s.charAt(j)) {
            return false;
        }
        i++; 
        j--;
        return isPalindrome(s,i,j);
    }
    public static void main(String[] args) {
        
        String s = "madam";
        System.out.println("Is it a Palindrome : " + isPalindrome(s,0,4));
        
    }
}
