package Recursion;

/*

    Description:
        Following program demonstrates the implementation of the "Factorial" calculation
        using a recursive approach...

    Problem Statement:
        -> Given a positive integer n...
        -> The task is to calculate its factorial (n!)...
        -> Factorial is defined as the product of all positive integers less than or equal to n...
        -> Mathematically expressed as: n! = n × (n-1) × (n-2) × ... × 2 × 1...
        -> This fundamental calculation has applications in combinatorics, probability, and other mathematical fields...

    Approach:
        > Recursive Factorial Calculation:
            i. Use the mathematical recursive definition of factorial: n! = n × (n-1)!...
            ii. Establish a base case to terminate the recursion...
            iii. Follow a specific computation strategy:
                a. If n equals 1, return 1 (base case - 1! = 1)...
                b. Otherwise, return n multiplied by the factorial of (n-1)...
            iv. The recursion builds a chain of multiplications that is resolved as the call stack unwinds...

    Algorithm Steps:
        -> Recursive Factorial Implementation:
            1. Check base case: If n equals 1, return 1...
            2. Otherwise, recursively call calcFac(n-1) and multiply the result by n...
        -> Main Method Flow:
            1. Call calcFac function with test value 10...
            2. Print the resulting factorial value...

    Key Characteristics:
        -> Directly implements the mathematical definition of factorial...
        -> Demonstrates a classic use case for recursion...
        -> Uses a simple base case and recursive step...
        -> Solution is concise and elegant through recursion...

        > Implementation Details:
            -> Function accepts a single integer parameter...
            -> Returns the computed factorial rather than printing it...
            -> Tests the algorithm with factorial of 10 (10!)...
            -> Uses int data type which limits the size of factorial that can be computed...

    Time and Space Complexity:
        -> Time Complexity: O(n) - proportional to the input value...
        -> Space Complexity: O(n) for the recursion stack...

    Limitations:
        -> Using int data type limits calculations to relatively small values (n ≤ 12)...
        -> Factorial grows extremely quickly and will cause integer overflow for larger inputs...
        -> Missing error handling for zero or negative inputs...
        -> For large inputs, a non-recursive implementation might be more efficient...

*/

public class Factorial {

    public static int calcFac(int n) {
        if(n==1)return 1;
        return n*calcFac(n-1);
    }
    
    public static void main(String[] args) {
        System.out.println(calcFac(10));
    }
}
