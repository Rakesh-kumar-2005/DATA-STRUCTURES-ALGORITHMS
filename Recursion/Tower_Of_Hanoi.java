package Recursion;

/*

Description:
    This program implements the classic Tower of Hanoi puzzle using recursion...
    Tower of Hanoi is a mathematical puzzle consisting of three rods and a number of disks of different sizes...
    The objective is to move the entire stack of disks from one rod to another, following specific rules...

Problem Statement:
    -> Given n disks stacked on a source rod (src) in order of decreasing size from bottom to top...
    -> Move all disks to a destination rod (dest) using a helper rod (hel)...
    -> Rules:
       - Only one disk can be moved at a time...
       - Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack...
       - No disk may be placed on top of a smaller disk...

Approach:
    > Recursive Solution:
        1. Recognize that to move n disks from source to destination, we can:
           - Move n-1 disks from source to helper rod...
           - Move the largest disk (nth disk) from source to destination...
           - Move the n-1 disks from helper to destination...
        2. This naturally forms a recursive pattern that can solve the entire puzzle...

Algorithm Steps:
    -> towerOfHanoi() Method:
        1. Base case: If only one disk (n=1):
           - Move the disk directly from source to destination and return...
        2. Recursive case (n>1):
           a. Move n-1 disks from source to helper using destination as auxiliary...
           b. Move the nth (largest) disk from source to destination...
           c. Move n-1 disks from helper to destination using source as auxiliary...
        3. Each step is printed to show the movement of disks...
        
    -> Main Method Flow:
        1. Call towerOfHanoi() with n=3 disks and three rods labeled 'A' (source), 'B' (helper), and 'C' (destination)...

Key Characteristics:
    -> Demonstrates divide-and-conquer approach to problem-solving...
    -> Uses recursion to break down a complex problem into simpler subproblems...
    -> Follows a specific pattern of movements that guarantees a solution...
    -> Prints each step of the solution to visualize the disk movements...
    -> The optimal solution requires 2^n - 1 moves for n disks...

Implementation Details:
    -> The package is named "Recursion"...
    -> Uses a public static method for the recursive algorithm...
    -> Takes parameters:
       - n: number of disks...
       - src: character representing the source rod...
       - hel: character representing the helper rod...
       - dest: character representing the destination rod...
    -> Prints each move to the console using System.out.println()...
    -> Tests the implementation with 3 disks...

Time and Space Complexity:
    -> Time Complexity: O(2^n) where n is the number of disks...
       (Each disk essentially doubles the number of moves required)...
    -> Space Complexity: O(n) for the recursion stack...
       (Maximum recursion depth equals the number of disks)...

Potential Improvement:
    -> Could add visualization of the disk positions after each move...
    -> Could track and display the total number of moves performed...
    -> Could implement an iterative solution to avoid recursion stack limitations...
    -> Could add user input for number of disks and rod labels...

*/

public class Tower_Of_Hanoi {

     public static void towerOfHanoi(int n, char src, char hel, char dest){
        if (n == 1) {
            System.out.println("Move Disk 1 from " + src + " to " + dest);
            return;
        }
     
        towerOfHanoi(n-1, src, dest, hel);
        System.out.println("Move disk " + n + " from rod " + src + " to " + dest);
        towerOfHanoi(n-1,hel,src,dest);
    }
    public static void main(String[] args) {
        System.out.println("A tower with 3 disk : ");
        towerOfHanoi(3,'A','B','C');
    }
}
