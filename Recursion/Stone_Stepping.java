package Recursion1;

/*

    Description:
        Following program demonstrates the implementation of the "Minimum Cost Stone Stepping" problem
        using a recursive approach with dynamic decision making...

    Problem Statement:
        -> Given an array of integers representing stone heights...
        -> A person can jump from stone i to either stone i+1 (one step) or stone i+2 (two steps)...
        -> The cost of jumping from stone i to stone j is the absolute difference between their heights |stones[i] - stones[j]|...
        -> The task is to find the minimum total cost to reach the last stone from the first stone...
        -> This represents a classic optimization problem with multiple possible paths...

    Approach:
        > Recursive Path Optimization:
            i. Use recursion to explore all possible jumping patterns...
            ii. At each stone, consider both one-step and two-step jumps...
            iii. Follow a specific optimization strategy:
                a. Calculate the cost of jumping to the next stone (one step)...
                b. Calculate the cost of jumping to the stone after next (two steps)...
                c. Choose the minimum of these two options...
                d. Accumulate the costs along the path...
            iv. The recursion terminates when reaching the last stone...

    Algorithm Steps:
        -> Recursive Minimum Cost Implementation:
            1. Check base case: If current index equals n-1 (reached last stone), return 0...
            2. Calculate cost1 = cost of one-step jump + minimum cost from next position:
               - |stones[idx] - stones[idx+1]| + minCost(stones, n, idx+1)...
            3. Handle edge case: If at second-to-last stone, return cost1 (only one step possible)...
            4. Calculate cost2 = cost of two-step jump + minimum cost from position after next:
               - |stones[idx] - stones[idx+2]| + minCost(stones, n, idx+2)...
            5. Return the minimum of cost1 and cost2...
        -> Main Method Flow:
            1. Define a test array of stone heights...
            2. Call minCost function with the array, its length, and starting index 0...
            3. Print the resulting minimum cost...

    Key Characteristics:
        -> Uses divide-and-conquer to break down the problem into subproblems...
        -> Explores multiple paths to find the optimal solution...
        -> Makes greedy choice at each step based on accumulated future cost...
        -> Demonstrates recursive approach to optimization problems...

        > Implementation Details:
            -> Function accepts three parameters: stone array, array length, and current index...
            -> Returns the minimum total cost rather than printing it...
            -> Uses Math.abs() and Math.min() for computations...
            -> Tests with an array of 6 stone heights...

    Time and Space Complexity:
        -> Time Complexity: O(2^n) where n is the number of stones...
           (Without memoization, potentially exponential due to overlapping subproblems)
        -> Space Complexity: O(n) for the recursion stack...

    Potential Improvement:
        -> The algorithm could be optimized using dynamic programming (memoization)...
        -> This would reduce time complexity to O(n) by avoiding recalculation of subproblems...

*/

public class Stone_Stepping {

    private static int minCost(int[] stones, int n, int idx){
        if(idx == n-1) {
            return 0;
        }
        
        int cost1 = Math.abs(stones[idx] - stones[idx+1]) + minCost(stones, n, idx+1);
        if(n-2 == idx) return cost1;
        int cost2 = Math.abs(stones[idx] - stones[idx+2]) + minCost(stones, n, idx+2);

        return Math.min(cost1,cost2);
    }
    
    public static void main(String[] args) {
        
        int[] stones = {10,53,43,85,78,23};
        System.out.println("Minimum cost will be = " + minCost(stones, stones.length,0));
    
    }
}
