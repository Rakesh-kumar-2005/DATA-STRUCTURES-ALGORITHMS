package Recursion;

/*

Description:
  Following program demonstrates the solution to the "Print All Combinations of a Given Size" problem using recursion...

Problem Statement:
  -> Given an array of integers...
  -> Print all possible combinations of a specific size (key)...
  -> Each combination should include exactly 'key' elements from the array...

Approach:
  > Recursive Backtracking:
     i. Use a recursive function to build combinations element by element...
     ii. Maintain a temporary array to store the current combination being constructed...
     iii. Print each complete combination when it reaches the required size...

> Algorithm Steps:
  -> Initialize a temporary array 'data' of size 'key' to store current combination...
  -> Start with the first element (index 0) and recursively build combinations...
  -> For each recursive call:
     * If index == key, a complete combination is formed - print it and return...
     * Otherwise, try each possible element for the current position and recurse...
  -> Use the optimization condition (end - i + 1 >= key - index) to prune recursion paths...

> Recursive Function Parameters:
  -> arr: The original input array...
  -> data: Temporary array to store the current combination...
  -> start: Starting index for considering elements from the original array..
  -> end: Ending index of the original array...
  -> index: Current position in the combination being built...
  -> key: Required size of each combination...

> Example:
  -> For input array [1, 2, 3, 4, 3, 2, 8, 0, 5] and key = 2...
  -> Prints all possible 2-element combinations from the array...
  -> Output includes combinations like [1,2], [1,3], [1,4], etc...
  -> Note that combinations with duplicate values are treated as unique if they come from different positions...

> Optimization:
  -> The condition (end - i + 1 >= key - index) checks if there are enough remaining elements...
  -> This prevents unnecessary recursive calls when it's impossible to form a combination of required size...

> Time and Space Complexity:
  -> Time Complexity: O(n choose k) or O(n!/(k!(n-k)!)) where n is the array length and k is the key value...
  -> Space Complexity: O(k) for the temporary array, plus O(k) for the recursion stack...

*/

public class Print_All_Combinations {

    private static void combination(int[] arr, int[] data, int start, int end, int index, int key) {

        if (index == key) {
            for (int num : data) {
                System.out.print(num + " ");
            }
            System.out.println();
            return;
        }

        for (int i = start; i <= end && end - i + 1 >= key - index; i++) {
            data[index] = arr[i];
            combination(arr, data, i + 1, end, index + 1, key);
        }
    }

    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8};
        int key = 4;
        int[] data = new int[key];
        combination(arr, data, 0, arr.length - 1, 0, key);
    }
}
