package Graph;

/*

Description:
    -> This program implements the Bellman-Ford Algorithm to find the shortest distances from a single source node to all other nodes in a weighted directed graph...
    -> The algorithm can handle graphs containing negative edge weights...
    -> If a negative weight cycle exists, the program detects it and returns [-1] to indicate the presence of such a cycle...

Problem Statement:
    Given a graph with V vertices and a list of edges, where each edge is represented as {u, v, w} meaning there is a directed edge from node u to node v with weight w...
    Find the shortest distance from a given source vertex to every other vertex in the graph...
    If there is a negative weight cycle in the graph, return [-1]...

Example:
    Input:
        V = 8...
        edges = {{0,1,5},{1,2,3},{2,3,1},{3,4,2},{4,5,4},{5,6,6},{6,7,2},{7,0,7}}...
        src = 0...
    Output:
        Distance from 0 to 0 is 0...
        Distance from 0 to 1 is 5...
        Distance from 0 to 2 is 8...
        Distance from 0 to 3 is 9...
        Distance from 0 to 4 is 11...
        Distance from 0 to 5 is 15...
        Distance from 0 to 6 is 21...
        Distance from 0 to 7 is 23...

Approach:
    1. Initialize the distance array with a large value (infinity) for all vertices except the source, which is set to 0...
    2. Relax all edges (V - 1) times...
       -> For each edge (u, v, w), if dist[u] + w < dist[v], update dist[v] = dist[u] + w...
    3. Perform one additional iteration to check for negative weight cycles...
       -> If any distance can still be updated, it means a negative cycle exists, and the function returns [-1]...
    4. If no negative cycle is found, return the distance array...

Key Observations:
    -> Bellman-Ford works on graphs with negative weights, unlike Dijkstraâ€™s algorithm...
    -> It can detect negative weight cycles effectively...
    -> The algorithm is based on the relaxation principle, where shortest paths improve step by step...

Time and Space Complexity:
    -> Time Complexity: O(V * E)...
       (Each of the V - 1 iterations processes all edges)...
    -> Space Complexity: O(V)...
       (For storing distance values)...

Example Walkthrough:
    Step 1: Initialize all distances to infinity, except source = 0...
    Step 2: Relax all edges 7 times (for 8 vertices)...
    Step 3: Check for negative weight cycles...
    Step 4: Print the final shortest distances...

*/

public class Bellman_Ford_Algorithm {

    private static int[] bellmanFord(int V, int[][] edges, int src) {
        int[] dist = new int[V];
        
        for (int i = 0; i < V; i++) {
            dist[i] = (int) 1e8;
        }
        dist[src] = 0;

        for (int i = 0; i < V - 1; i++) {
            for (int[] it : edges) {
                int u = it[0];
                int v = it[1];
                int w = it[2];

                if (dist[u] != (int) 1e8 && dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                }
            }
        }

        for (int[] it : edges) {
            int u = it[0];
            int v = it[1];
            int w = it[2];

            if (dist[u] != (int) 1e8 && dist[u] + w < dist[v]) {
                int[] temp = new int[1];
                temp[0] = - 1;
                return temp;
            }

        }

        return dist;

    }

    public static void main(String[] args) {

        int[][] edges = {{0, 1, 5}, {1, 2, 3}, {2, 3, 1}, {3, 4, 2}, {4, 5, 4}, {5, 6, 6}, {6, 7, 2}, {7, 0, 7}};
        int V = 8;
        int src = 0;

        int[] dist = bellmanFord(V, edges, src);

        for (int i = 0; i < V; i++) {
            System.out.println("Distance from " + src + " to " + i + " is " + dist[i]);
        }

    }

}
