package Math_Problems;

/*

Description:
    Following program demonstrates the solution to the "Count Prime Numbers" problem
    using the Sieve of Eratosthenes algorithm for efficient prime counting...

Problem Statement:
    -> Given an integer n...
    -> Count the number of prime numbers that are strictly less than n...
    -> A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself...
    -> Return the total count of such prime numbers...

Approach:
    > Sieve of Eratosthenes Algorithm:
        i. Create a boolean-like array to mark composite (non-prime) numbers...
        ii. Systematically mark all multiples of each prime number as composite...
        iii. Count the remaining unmarked numbers which are prime...

    > Algorithm Steps:
        -> Base case handling:
            1. If n < 2, return 0 since there are no prime numbers less than 2...

        -> Sieve initialization:
            1. Create an array of size n initialized with 0s (0 represents potential prime)...
            2. Index i in the array represents the number i, and arr[i] = 0 means i is prime...

        -> Sieve marking process:
            1. Iterate from 2 to √n (i * i < n condition)...
            2. For each unmarked number i (arr[i] == 0), it's a prime...
            3. Mark all multiples of i starting from i² as composite (arr[j] = 1)...
            4. Start from i² because smaller multiples would have been marked by smaller primes...
            5. Increment by i to mark all multiples: i², i²+i, i²+2i, etc...

        -> Prime counting:
            1. Iterate through the array from 2 to n-1...
            2. Count all numbers where arr[i] == 0 (unmarked numbers are prime)...
            3. Return the final count...

    > Key Characteristics:
        -> Uses the principle that every composite number has a prime factor ≤ √n...
        -> Efficiently eliminates all composite numbers through systematic marking...
        -> Avoids redundant checks by starting multiples from i² instead of 2*i...
        -> Works optimally for counting primes in a range rather than checking individual numbers...
        -> Handles edge cases like n < 2 where no primes exist...

    > Implementation Details:
        -> Uses an integer array where 0 represents prime and 1 represents composite...
        -> The outer loop runs only until √n, significantly reducing iterations...
        -> Inner loop marks multiples efficiently using arithmetic progression...
        -> Final counting loop processes only numbers from 2 to n-1...
        -> Demonstrates the algorithm with n = 10, expecting primes: 2, 3, 5, 7...

    > Time and Space Complexity:
        -> Time Complexity: O(n log log n) due to the sieve marking process...
        -> Space Complexity: O(n) for the array to store prime/composite markings...
        -> More efficient than checking each number individually for primality...
   
*/

public class Count_Prime_Numbers {

    private static int countPrimes(int n) {

        if (n < 2) {
            return 0;
        }

        int count = 0;
        int[] arr = new int[n];

        for (int i = 2; i * i < n; i++) {

            if (arr[i] == 0) {
                for (int j = i * i; j < n; j += i) {
                    arr[j] = 1;
                }
            }

        }

        for (int i = 2; i < n; i++) {
            if (arr[i] == 0) {
                count++;
            }
        }

        return count;
    }

    public static void main(String[] args) {

        int n = 10;
        System.out.println("The number of prime numbers till " + n + " is : " + countPrimes(n));
    }

}
