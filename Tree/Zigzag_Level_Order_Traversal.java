package Tree;

/*

Description:
    This program performs a zigzag level order traversal of a binary tree...
    Zigzag traversal visits nodes level by level, alternating between left-to-right and right-to-left directions...
    The result is returned as a collection of node values at each level...

Problem Statement:
    -> Given a binary tree, return its zigzag level order traversal...
    -> Zigzag traversal means:
       - First level is traversed from left to right...
       - Second level is traversed from right to left...
       - Third level is traversed from left to right again...
       - And so on, alternating directions with each level...
    -> The program implements an iterative approach using a queue data structure...

Approach:
    > Level Order Traversal with Direction Toggle:
        1. Use a standard level order traversal with a queue...
        2. Maintain a flag to track the current direction (left-to-right or right-to-left)...
        3. Process each level completely before moving to the next...
        4. For levels requiring right-to-left order, reverse the collected values...
        5. Toggle the direction flag after processing each level...

Algorithm Steps:
    -> zigzagLevelOrder() Method:
        1. Initialize the result as an ArrayList of ArrayLists...
        2. Handle base case: If the root is null, return the empty result...
        3. Create a queue for level order traversal and add the root node...
        4. Initialize a boolean flag to true (indicating left-to-right direction)...
        5. While the queue is not empty:
           a. Get the current level size (number of nodes at this level)...
           b. Create a temporary list to store the current level's values...
           c. Process all nodes at the current level:
              - Remove a node from the queue...
              - Add its value to the temporary list...
              - Add its children (if any) to the queue...
           d. If flag is false (right-to-left direction), reverse the temporary list...
           e. Add the temporary list to the result...
           f. Toggle the flag for the next level...
        6. Return the final result...
        
    -> Main Method Flow:
        1. Create a sample binary tree with 7 nodes (complete binary tree of height 3)...
        2. Call zigzagLevelOrder() with the root node...
        3. Print the zigzag level order traversal of the tree...

Key Characteristics:
    -> Uses breadth-first search (BFS) approach for level order traversal...
    -> Implements the zigzag pattern by reversing alternate levels...
    -> Processes all nodes at each level before moving to the next level...
    -> Maintains the original tree structure while traversing...
    -> Returns a nested list structure where each inner list represents one level...

Implementation Details:
    -> The package is named "Tree"...
    -> Defines a static inner class TreeNode to represent each node in the binary tree...
    -> Each TreeNode contains:
       - An integer value (val)...
       - References to left and right child nodes (initialized to null)...
    -> Uses a LinkedList as a Queue implementation for level order traversal...
    -> Uses ArrayList to store results...
    -> Uses Collections.reverse() to change the order of nodes at alternate levels...
    -> Constructs a sample binary tree with 7 nodes in the main method...

Time and Space Complexity:
    -> Time Complexity: O(n) where n is the number of nodes in the tree...
       (Each node is processed exactly once, with O(1) work per node plus occasional O(k) reversal operations where k is the width of the level)...
    -> Space Complexity: O(n) for storing the result and the queue...
       (The queue can contain at most n/2 nodes in a perfect binary tree)...

Potential Improvement:
    -> Could implement a more efficient approach that doesn't require reversing lists...
    -> Could use a deque (double-ended queue) to avoid reversal operations...
    -> Could be extended to support more complex traversal patterns...
    -> Could add visualization of the traversal order...

*/

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;

public class Zigzag_Level_Order_Traversal {

    static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        public TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }

    }

    private static ArrayList<ArrayList<Integer>> zigzagLevelOrder(TreeNode root) {
        
        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        if (root == null) {
            return ans;
        }

        Queue<TreeNode> q = new LinkedList<>();
        boolean flag = true;
        q.add(root);

        while (! q.isEmpty()) {
            int size = q.size();
            ArrayList<Integer> temp = new ArrayList<>();

            for (int i = 0; i < size; i++) {

                TreeNode curr = q.poll();
                temp.add(curr.val);

                if (curr.left != null) {
                    q.add(curr.left);
                }

                if (curr.right != null) {
                    q.add(curr.right);
                }
            }

            if (! flag) {
                Collections.reverse(temp);
            }
            ans.add(temp);
            flag = ! flag;
        }
        return ans;
    }

    public static void main(String[] args) {

        TreeNode root = new TreeNode(1);

        root.left = new TreeNode(2);
        root.right = new TreeNode(3);

        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);

        root.right.left = new TreeNode(6);
        root.right.right = new TreeNode(7);

        ArrayList<ArrayList<Integer>> ans = zigzagLevelOrder(root);

        System.out.println("Zig Zag Level order traversal of the Binary Tree is : ");

        for (ArrayList<Integer> curr : ans) {
            System.out.println(curr);
        }
    }

}
