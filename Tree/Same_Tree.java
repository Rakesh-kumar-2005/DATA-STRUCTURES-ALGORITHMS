package Tree;

/*

Description:
    This program determines if two binary trees are structurally identical and have the same node values using recursion...
    Two binary trees are considered the same if they are structurally identical and the nodes have the same value...

Problem Statement:
    -> Given two binary trees, check if they are the same tree...
    -> Two binary trees are considered identical if:
       - They have the same structure (arrangement of nodes)...
       - Corresponding nodes have the same values...
    -> The program implements a recursive approach to compare the trees node by node...

Approach:
    > Recursive Tree Comparison:
        1. Compare the structure and values of both trees simultaneously using recursion...
        2. Check if the current nodes are structurally the same (both null or both non-null)...
        3. For non-null nodes, compare their values...
        4. Recursively compare the left subtrees and right subtrees...
        5. All three conditions (current node values, left subtrees, right subtrees) must match for trees to be identical...

Algorithm Steps:
    -> isSameTree() Method:
        1. Base case for structure check: If either node is null, return true only if both are null...
           - This handles both the case where both are null (return true) and one is null (return false)...
        2. Recursively compare the left subtrees of both trees...
        3. Recursively compare the right subtrees of both trees...
        4. Check if the values of current nodes are equal...
        5. Return true only if all three conditions are satisfied:
           - Current node values are equal...
           - Left subtrees are identical...
           - Right subtrees are identical...
        
    -> Main Method Flow:
        1. Create two sample binary trees with 7 nodes each...
        2. Trees are structurally identical but have one different node value (tree1.left.left.val = 4, tree2.left.left.val = 8)...
        3. Call isSameTree() with both tree roots to check if they are identical...
        4. Print an appropriate message based on the result...

Key Characteristics:
    -> Uses pre-order traversal (node, left, right) for comparison...
    -> Handles structural differences and value differences separately...
    -> Uses short-circuit evaluation with logical AND (&&) to combine results...
    -> Efficiently handles base cases for null nodes...
    -> Returns early if any discrepancy is found (due to short-circuit evaluation)...

Implementation Details:
    -> The package is named "Tree"...
    -> Defines a static inner class TreeNode to represent each node in the binary tree...
    -> Each TreeNode contains:
       - An integer value (val)...
       - References to left and right child nodes (initialized to null)...
    -> Uses a private static method for the recursive comparison algorithm...
    -> Constructs two sample binary trees in the main method that differ in one node value...
    -> Returns a boolean indicating if the trees are identical...

Time and Space Complexity:
    -> Time Complexity: O(min(n, m)) where n and m are the number of nodes in the trees...
       (Only needs to examine nodes until a difference is found)...
    -> Space Complexity: O(min(h1, h2)) where h1 and h2 are the heights of the trees...
       (Due to the recursion stack, worst case O(n) for skewed trees)...

Potential Improvement:
    -> Could implement an iterative approach using a queue or stack to avoid recursion stack limitations...
    -> Could add more detailed reporting of where differences are found...
    -> Could be extended to find if one tree is a subtree of another...
    -> Could implement a more generalized tree comparison with customizable equality criteria...

*/

public class Same_Tree {

    static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        public TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }

    }

    private static boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null || q == null) {
            return p == q;
        }

        boolean leftSide = isSameTree(p.left, q.left);
        boolean rightSide = isSameTree(p.right, q.right);

        boolean values = (p.val == q.val);

        return values && leftSide && rightSide;
    }

    public static void main(String[] args) {

        TreeNode tree1 = new TreeNode(1);

        tree1.left = new TreeNode(2);
        tree1.right = new TreeNode(3);

        tree1.left.left = new TreeNode(4);
        tree1.left.right = new TreeNode(5);

        tree1.right.left = new TreeNode(6);
        tree1.right.right = new TreeNode(7);

        TreeNode tree2 = new TreeNode(1);

        tree2.left = new TreeNode(2);
        tree2.right = new TreeNode(3);

        tree2.left.left = new TreeNode(8);
        tree2.left.right = new TreeNode(5);

        tree2.right.left = new TreeNode(6);
        tree2.right.right = new TreeNode(7);

        if (isSameTree(tree1, tree2)) {
            System.out.println("Both trees are exactly the same...");
        } else {
            System.out.println("Both trees are different from each other...");
        }
    }

}
