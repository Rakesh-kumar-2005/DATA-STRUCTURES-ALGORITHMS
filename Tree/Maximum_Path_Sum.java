package Tree;

/*

Description:
    This program finds the maximum path sum in a binary tree using recursion...
    A path is defined as any sequence of nodes from some starting node to any node in the tree...
    The path must contain at least one node and does not need to go through the root...

Problem Statement:
    -> Given a binary tree, find the path with the maximum sum...
    -> The path can start and end at any node in the tree...
    -> The path may not necessarily pass through the root...
    -> The path can include negative values, but we ignore branches that would reduce the total sum...

Approach:
    > Recursive Path Sum Calculation with Global Tracking:
        1. For each node, calculate two different values:
           - Maximum path sum that passes through the current node as a turning point...
           - Maximum path sum that starts from the current node and extends upward to ancestors...
        2. Track the global maximum path sum using a pass-by-reference array...
        3. Handle negative values by taking the maximum of path sum and 0 (effectively pruning negative branches)...

Algorithm Steps:
    -> maxPathSum() Method:
        1. Base case: If the root is null (empty tree), return 0...
        2. Recursively calculate the maximum path sum extending from the left child...
           - Take maximum of the result and 0 to ignore negative-sum paths...
        3. Recursively calculate the maximum path sum extending from the right child...
           - Take maximum of the result and 0 to ignore negative-sum paths...
        4. Calculate the total path sum through current node as a turning point:
           - root.val + leftSum + rightSum...
        5. Update the global maximum in the array if current total sum is greater...
        6. Return the maximum single path extending upward from current node:
           - root.val + max(leftSum, rightSum)...
        
    -> maxPath() Method:
        1. Handle the base case: If the root is null, return 0...
        2. Create a single-element array to track the maximum path sum...
        3. Initialize the array with Integer.MIN_VALUE to handle all-negative trees...
        4. Call maxPathSum() with the root and the array...
        5. Return the maximum path sum found (stored in the array)...

    -> Main Method Flow:
        1. Create a sample binary tree with 7 nodes...
        2. Call maxPath() with the root node...
        3. Print the calculated maximum path sum of the tree...

Key Characteristics:
    -> Uses post-order traversal (left, right, node) to calculate sums bottom-up...
    -> Handles negative values by pruning branches that would reduce the total sum...
    -> Distinguishes between paths passing through a node and paths ending at a node...
    -> Uses an array parameter as a reference to track the global maximum sum...
    -> Handles special cases like all-negative trees by initializing with Integer.MIN_VALUE...

Implementation Details:
    -> The package is named "Tree"...
    -> Defines a static inner class TreeNode to represent each node in the binary tree...
    -> Each TreeNode contains:
       - An integer value (val)...
       - References to left and right child nodes (initialized to null)...
    -> Uses a private static method maxPathSum() for the recursive algorithm...
    -> Uses a single-element array to simulate pass-by-reference behavior in Java...
    -> Constructs a sample binary tree with 7 nodes in the main method...

Time and Space Complexity:
    -> Time Complexity: O(n) where n is the number of nodes in the tree...
       (Each node is processed exactly once)...
    -> Space Complexity: O(h) where h is the height of the tree...
       (Due to the recursion stack, worst case O(n) for skewed trees)...

Potential Improvement:
    -> Could implement an iterative approach to avoid recursion stack limitations...
    -> Could add functionality to also return the actual nodes that form the maximum path...
    -> Could be extended to handle different types of path constraints...
    -> Could include additional visualizations of the paths considered...

*/

public class Maximum_Path_Sum {

    static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }
    }

    private static int maxPathSum(TreeNode root, int[] arr) {
        if (root == null) {
            return 0;
        }

        int leftSum = Math.max(0, maxPathSum(root.left, arr));
        int rightSum = Math.max(0, maxPathSum(root.right, arr));

        int totalPathSum = root.val + leftSum + rightSum;
        arr[0] = Math.max(arr[0], totalPathSum);

        return root.val + Math.max(leftSum, rightSum);

    }

    private static int maxPath(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int[] arr = new int[1];
        arr[0] = Integer.MIN_VALUE;

        maxPathSum(root, arr);

        return arr[0];
    }

    public static void main(String[] args) {
        TreeNode root = new TreeNode(1);

        root.left = new TreeNode(2);
        root.right = new TreeNode(3);

        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);

        root.right.left = new TreeNode(6);
        root.right.right = new TreeNode(7);

        System.out.println("Maximum path sum is : " + maxPath(root));
    }
}
