package Tree;

/*

Description:
    This program calculates the diameter of a binary tree using recursion...
    The diameter of a binary tree is the length of the longest path between any two nodes in the tree...
    This path may or may not pass through the root of the tree...

Problem Statement:
    -> Given a binary tree, find its diameter...
    -> The diameter is the length of the longest path between any two nodes in the tree...
    -> The path length is represented by the number of edges between the nodes...
    -> For example, in a tree with height 3 and a balanced structure, the diameter could be 4...

Approach:
    > Recursive Height Calculation with Diameter Tracking:
        1. Modify the height calculation function to also track the maximum diameter found...
        2. For each node, calculate the sum of heights of left and right subtrees...
        3. Update the maximum diameter if the current path length is greater...
        4. Use a single-element array to pass by reference and track the maximum diameter...

Algorithm Steps:
    -> maxLength() Method:
        1. Base case: If the root is null (empty tree), return 0...
        2. Recursively calculate the height of the left subtree...
        3. Recursively calculate the height of the right subtree...
        4. Calculate the total length (potential diameter) through current node:
           - Add left and right heights (this gives path length through current node)...
        5. Update the maximum diameter in the array if current total length is greater...
        6. Return the height of current subtree (max of left and right + 1)...
        
    -> diameterOfBinaryTree() Method:
        1. Handle the base case: If the root is null, return 0...
        2. Create a single-element array to track the maximum diameter...
        3. Call maxLength() with the root and the array...
        4. Return the maximum diameter found (stored in the array)...

    -> Main Method Flow:
        1. Create a sample binary tree with 7 nodes (complete binary tree of height 3)...
        2. Call diameterOfBinaryTree() with the root node...
        3. Print the calculated diameter of the tree...

Key Characteristics:
    -> Uses post-order traversal (left, right, node) to calculate heights bottom-up...
    -> Combines height calculation and diameter tracking in a single traversal...
    -> Uses an array parameter as a reference to track the maximum diameter...
    -> Handles the special case of an empty tree appropriately...
    -> The diameter calculation includes the number of edges (not nodes) in the path...

Implementation Details:
    -> The package is named "Tree"...
    -> Defines a static inner class TreeNode to represent each node in the binary tree...
    -> Each TreeNode contains:
       - An integer value (val)...
       - References to left and right child nodes (initialized to null)...
    -> Uses a private static method maxLength() for the recursive algorithm...
    -> Uses a single-element array to simulate pass-by-reference behavior in Java...
    -> Constructs a sample binary tree with 7 nodes in the main method...

Time and Space Complexity:
    -> Time Complexity: O(n) where n is the number of nodes in the tree...
       (Each node is processed exactly once)...
    -> Space Complexity: O(h) where h is the height of the tree...
       (Due to the recursion stack, worst case O(n) for skewed trees)...

Potential Improvement:
    -> Could implement an iterative approach to avoid recursion stack limitations...
    -> Could add functionality to identify and return the actual nodes that form the diameter...
    -> Could extend to return multiple paths if there are multiple paths with the same maximum length...
    -> Could be optimized further for specific tree structures...

*/

public class Diameter_of_Binary_Tree {

    static class TreeNode {

        int val;
        TreeNode left;
        TreeNode right;

        public TreeNode(int val) {
            this.val = val;
            this.left = null;
            this.right = null;
        }

    }

    private static int maxLength(TreeNode root, int[] arr) {
        if (root == null) {
            return 0;
        }

        int leftHeight = maxLength(root.left, arr);
        int rightHeight = maxLength(root.right, arr);

        int totalLength = rightHeight + leftHeight;
        arr[0] = Math.max(arr[0], totalLength);

        int maxHeight = Math.max(rightHeight, leftHeight);

        return 1 + maxHeight;
    }

    private static int diameterOfBinaryTree(TreeNode root) {
        if (root == null) {
            return 0;
        }

        int[] arr = new int[1];
        maxLength(root, arr);

        return arr[0];
    }

    public static void main(String[] args) {

        TreeNode root = new TreeNode(1);

        root.left = new TreeNode(2);
        root.right = new TreeNode(3);

        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);

        root.right.left = new TreeNode(6);
        root.right.right = new TreeNode(7);

        int diameter = diameterOfBinaryTree(root);

        System.out.println("Diameter of the Tree is : " + diameter);
    }
}
