package Stack;

/*

    Description:
        Following program demonstrates the solution to the "Balanced Brackets" problem 
        using Stack-based Validation Approach...

    Problem Statement:
        -> Determine if a given string of brackets is balanced...
        -> A string is considered balanced if each opening bracket has a corresponding closing bracket in the correct order...
        -> The problem handles three types of brackets: parentheses (), curly braces {}, and square brackets []...
        -> Every closing bracket must match the most recently opened unmatched bracket...

    Approach:
        > Stack-based Bracket Validation:
            i. Use a stack data structure to track opening brackets...
            ii. Process the string character by character...
            iii. Push opening brackets onto the stack...
            iv. For closing brackets, check if they match the top of the stack...
            v. A balanced string will result in an empty stack...

    Algorithm Steps:
        -> Initialize an empty stack for bracket tracking...
        -> Process each character in the input string:
            1. If character is an opening bracket ('(', '{', '['), push onto stack...
            2. If character is a closing bracket (')', '}', ']'):
                * Check if stack is empty - return false if empty...
                * Compare with top element of stack...
                * If matching pair, pop from stack...
                * If not matching, return false...
        -> Final Validation:
            1. Check if stack is empty after processing all characters...
            2. Return true if empty (balanced), false otherwise (unbalanced)...

    Key Characteristics:
        -> Efficiently handles nested brackets of different types...
        -> Uses LIFO (Last In First Out) property of stacks for validation...
        -> Ensures proper nesting and ordering of brackets...
        -> Returns early for obvious unbalanced cases...

        > Validation Mechanism:
            -> Opening brackets are always pushed onto stack...
            -> Closing brackets must match the most recent opening bracket...
            -> Stack becomes empty when all brackets are properly matched...

    Time and Space Complexity:
        -> Time Complexity: O(n) where n is the length of the input string...
        -> Space Complexity: O(n) for the stack in worst case scenario...

*/

import java.util.Scanner;
import java.util.Stack;

public class Balance_Brackets_2 {
    
    private static boolean isBalanced(String brackets, Stack<Character> st){
        
        for (int i = 0; i < brackets.length(); i++){
            char currChar = brackets.charAt(i);
            
            if(st.isEmpty() || currChar == '(' || currChar == '{' || currChar == '['){
                st.push(currChar);
            }else{
                if (st.isEmpty()) return false;
                    
                else{
                    if((currChar == ')' && st.peek() == '(') || (currChar == '}' && st.peek() == '{') || (currChar == ']' && st.peek() == '[')){
                        st.pop();
                    }else return false;
                    
                }
            }
        }
        return st.isEmpty();
    }

    public static void main(String[] args) {
        Stack<Character> st = new Stack<>();

        Scanner sc = new Scanner(System.in);
        System.out.println("Enter a string with every type of brackets :");
        String brackets = sc.next();

        System.out.println(isBalanced(brackets,st));
    }
}

